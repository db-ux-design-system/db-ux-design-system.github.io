---
/**
 * TextImage Component
 * Zeigt Text neben einem Bild an und bricht auf Mobile untereinander.
 */
import './TextImage.css';
import { DBTag } from '@db-ux/react-core-components';

interface Props {
  title?: string;
  imageSrc: string;
  imageAlt: string;
  imageSrcDark?: string;
  reversed?: boolean;
  contentAlign?: 'start' | 'center' | 'end';
  /**
   * Überschreibt die Headline-Größe (HTML Tag). Standard ist h4.
   */
  headlineLevel?: 1 | 2 | 3 | 4 | 5 | 6;
  /**
   * Verhältnis zwischen Text und Bild. "50" = 50/50, "text-wide" = 66/33 (Text breiter).
   */
  imageWidth?: '50' | '33' | '66';
  /**
   * Grundlayout: horizontal (Standard nebeneinander) oder vertical (Bild über Text).
   */
  layout?: 'horizontal' | 'vertical';
  /** For vertical layout choose if image appears on top or bottom (default top) */
  imagePosition?: 'top' | 'bottom' | 'left' | 'right';
  /**
   * Optionaler Masken-Effekt für das Bild. Unterstützte Werte:
   * fade-right, fade-left, fade-top, fade-bottom,
   * fade-bottom-right, fade-bottom-left, fade-top-right, fade-top-left.
   */
  mask?: 
    | 'fade-right'
    | 'fade-left'
    | 'fade-top'
    | 'fade-bottom'
    | 'fade-bottom-right'
    | 'fade-bottom-left'
    | 'fade-top-right'
    | 'fade-top-left';
  /**
   * Rundet das Bild (aktiviert border-radius Styles)
   */
  rounded?: boolean;
  /**
   * Abstand zwischen Headline und Text.
   * "auto" drückt den Body nach unten; sm/md/lg/xl setzen festen Gap.
   * Standard ist "sm".
   */
  textGap?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl';
  /** Optional Tag above the body text */
  tag?: { label: string; emphasis?: 'strong' | 'weak' | 'default' };
}

const {
  title,
  imageSrc,
  imageAlt,
  imageSrcDark,
  imagePosition = 'right',
  contentAlign = 'center',
  imageWidth = '66',
  mask,
  rounded = false,
  textGap = 'sm',
  headlineLevel = 4,
  tag
} = Astro.props as Props;

// Headline stets h6 – Typografie kommt aus globalen Styles
---

<div
  class="text-image"
  data-image-position={imagePosition}
  data-image-width={imageWidth}
  data-content-align={contentAlign}
  data-text-gap={textGap}
>
  <div class="text-image__content">
  {tag && (
    <div class="text-image__tag" data-density="functional">
        <DBTag emphasis={tag.emphasis === 'default' ? undefined : tag.emphasis}>{tag.label}</DBTag>
    </div>)}
    {title && (
      headlineLevel === 1 ? <h1 class="text-image__title">{title}</h1>
      : headlineLevel === 2 ? <h2 class="text-image__title">{title}</h2>
      : headlineLevel === 3 ? <h3 class="text-image__title">{title}</h3>
      : headlineLevel === 4 ? <h4 class="text-image__title">{title}</h4>
      : headlineLevel === 5 ? <h5 class="text-image__title">{title}</h5>
      : <h6 class="text-image__title">{title}</h6>
    )}
    <div class="text-image__text">
      <slot />
    </div>
  </div>
  <div class="text-image__image">
    <img
        src={imageSrc}
        alt={imageAlt}
        loading="lazy"
        data-mask={mask}
        data-rounded={rounded ? 'true' : undefined}
        data-image-src={imageSrc}
        data-image-src-dark={imageSrcDark}/>
  </div>
</div>
<script>
    // sync image with the current color mode.
    if (typeof window !== 'undefined') {
        const shell = document.querySelector('.db-shell');
        const images = document.querySelectorAll<HTMLImageElement>('.text-image__image img[data-image-src]');

        if (shell && images.length > 0) {
            const applyMode = (mode: string | null) => {
                images.forEach((img) => {
                    const light = img.dataset.imageSrc;
                    const dark = img.dataset.imageSrcDark;
                    if (mode === 'dark' && dark) {
                        img.src = dark;
                    } else if (light) {
                        img.src = light;
                    }
                });
            };

            applyMode(shell.getAttribute('data-mode'));

            const observer = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    if (m.type === 'attributes' && m.attributeName === 'data-mode') {
                        applyMode(shell.getAttribute('data-mode'));
                    }
                }
            });

            observer.observe(shell, { attributes: true, attributeFilter: ['data-mode'] });
        }
    }
</script>